## 프로젝트 개요

NextRead는 Jetpack Compose와 Clean Architecture로 구축된 AI 기반 도서 추천 Android 앱입니다. Firebase를 통한 Google OAuth 인증을 사용하며, 도서 추천을 위해 백엔드 API와 통신합니다.

## 필수 설정 요구사항

### 사전 요구사항
- **Java 17 이상** (JDK 17 이상 필수)
- Android Studio (최신 버전)

### 필수 설정 파일

1. **google-services.json** (`app/google-services.json`)
   - Firebase Console에서 다운로드 (프로젝트: `nextread-472512`)
   - 패키지 이름: `com.nextread.readpick`
   - 각 개발자는 자신의 디버그 SHA-1 인증서 지문을 Firebase Console에 등록해야 함

2. **local.properties** (`local.properties`)
   - 반드시 포함: `BASE_URL=https://YOUR_NGROK_URL.ngrok-free.app/`
   - 이 BASE_URL은 빌드 타임에 `BuildConfig.BASE_URL`로 주입됨
   - ngrok 재시작 시 이 값을 업데이트해야 함

## 주요 개발 명령어

### 빌드 및 실행
```bash
# 디버그 APK 빌드
./gradlew assembleDebug

# 릴리스 APK 빌드
./gradlew assembleRelease

# 클린 빌드
./gradlew clean

# 연결된 기기/에뮬레이터에 설치
./gradlew installDebug
```

### 테스트
```bash
# 유닛 테스트 실행
./gradlew test

# 디버그 빌드 유닛 테스트 실행
./gradlew testDebugUnitTest

# 계측 테스트 실행 (연결된 기기/에뮬레이터 필요)
./gradlew connectedAndroidTest

# 특정 테스트 클래스 실행
./gradlew test --tests "com.nextread.readpick.YourTestClass"
```

### Firebase 설정
```bash
# Firebase 등록용 SHA-1 지문 확인
./gradlew signingReport
# "Variant: debug" 섹션에서 SHA1 값을 복사
```

### 코드 품질
```bash
# Lint 보고서 생성
./gradlew lint

# 빌드 설정 문제 확인
./gradlew dependencies
```

## 아키텍처

### Clean Architecture 레이어

코드베이스는 명확한 관심사 분리를 가진 Clean Architecture를 따릅니다:

1. **Presentation Layer** (`presentation/`)
   - Jetpack Compose UI 컴포넌트
   - ViewModel (MVVM 패턴)
   - Sealed class/Data class를 사용한 UI 상태 관리
   - 구조: `presentation/{feature}/{FeatureScreen|FeatureViewModel|FeatureUiState}`

2. **Domain Layer** (`domain/`)
   - Repository 인터페이스 (계약)
   - 비즈니스 로직 엔티티
   - Use case (필요시)

3. **Data Layer** (`data/`)
   - Repository 구현체 (`data/repository/`)
   - 네트워크 API 정의 (`data/remote/api/`)
   - DTO 및 요청/응답 모델 (`data/model/`)
   - DataStore를 사용한 로컬 저장소 (`data/local/`)
   - HTTP 인터셉터 (`data/remote/interceptor/`)

### Hilt를 사용한 의존성 주입

모든 의존성 주입은 `di/`의 Hilt 모듈을 통해 관리됩니다:

- **NetworkModule**: Retrofit, OkHttpClient, API 서비스 제공
- **RepositoryModule**: Repository 인터페이스를 구현체에 바인딩
- **DataStoreModule**: DataStore 인스턴스 제공

**중요**: DI 초기화를 위해 `ReadPickApplication`에 `@HiltAndroidApp` 어노테이션이 필요합니다.

### 인증 플로우

앱은 JWT 기반 인증 시스템을 사용합니다:

1. 사용자가 Firebase Auth를 통해 Google로 로그인
2. Firebase가 Google ID Token 반환
3. 앱이 백엔드로 ID Token 전송 (`POST /v1/api/auth/google`)
4. 백엔드가 토큰 검증 후 JWT access token 반환
5. JWT를 `TokenManager`를 통해 DataStore에 저장
6. `AuthInterceptor`가 이후 모든 API 요청에 `Authorization: Bearer {token}` 헤더를 자동으로 추가

**핵심 클래스**:
- `TokenManager`: DataStore에서 JWT 및 사용자 정보 관리 (비동기 안전)
- `AuthInterceptor`: API 요청 헤더에 JWT 자동 주입
- `AuthRepositoryImpl`: 로그인 플로우 및 토큰 저장 처리

### 네트워크 설정

**Base URL 관리**:
- `BASE_URL`은 `local.properties`에서 읽어 → `BuildConfig.BASE_URL`로 주입됨
- `NetworkModule`이 `BuildConfig.BASE_URL`을 읽어 Retrofit 설정
- 코드에 하드코딩된 URL 없음

**인터셉터**:
- `AuthInterceptor`: 요청에 JWT 토큰 추가 (`TokenManager.getToken()`을 동기적으로 사용)
- `LoggingInterceptor`: 모든 HTTP 요청/응답 로깅 (디버그 빌드)

**타임아웃**:
- Connect: 10초
- Read/Write: 30초

### 데이터 영속성

모든 로컬 저장소에 **DataStore** 사용 (SharedPreferences 아님):
- JWT access token
- 사용자 이메일, 이름, 프로필 사진
- `TokenManager` 싱글톤을 통해 접근

**중요**: `TokenManager.getToken()`은 동기 접근을 위해 `runBlocking` 사용 (OkHttp 인터셉터에 필요). ViewModel에서는 `getTokenFlow()` 사용 권장.

## 새 기능 추가하기

### 새 API 엔드포인트 추가

1. `data/remote/api/`에 API 인터페이스 정의 (예: `BookApi.kt`)
2. `data/model/`에 요청/응답 DTO 생성
3. `NetworkModule`에 provider 메서드 추가:
   ```kotlin
   @Provides
   @Singleton
   fun provideBookApi(retrofit: Retrofit): BookApi {
       return retrofit.create(BookApi::class.java)
   }
   ```
4. `domain/repository/`에 repository 인터페이스 생성
5. `data/repository/`에 repository 구현
6. `RepositoryModule`에서 인터페이스를 구현체에 바인딩

### 새 화면 추가

1. 새 패키지 생성: `presentation/{feature}/`
2. 파일 생성:
   - `{Feature}Screen.kt`: Composable UI
   - `{Feature}ViewModel.kt`: 상태 관리
   - `{Feature}UiState.kt`: UI 상태 sealed class/data class
3. `@HiltViewModel` 어노테이션으로 ViewModel 주입
4. `MainActivity` 또는 navigation graph에 navigation route 추가

### JSON 직렬화

데이터 클래스에 `@Serializable` 어노테이션 사용:
```kotlin
@Serializable
data class BookResponse(
    val id: String,
    val title: String,
    val author: String
)
```

JSON 파서 설정:
- 백엔드의 알 수 없는 키 무시
- null 값 유연하게 처리
- 관대한(lenient) 파싱 사용

## 기술 스택 참고사항

- **UI**: Jetpack Compose (Material 3)
- **아키텍처**: Clean Architecture + MVVM
- **DI**: Hilt (Dagger)
- **네트워크**: Retrofit 2.9.0 + OkHttp 4.12.0
- **비동기**: Kotlin Coroutines + Flow
- **직렬화**: Kotlinx Serialization (Gson/Moshi 아님)
- **인증**: Firebase Auth (Google OAuth)
- **로컬 저장소**: DataStore Preferences (SharedPreferences 아님)
- **이미지 로딩**: Coil
- **네비게이션**: Jetpack Navigation Compose
- **Min SDK**: 26 (Android 8.0)
- **Target/Compile SDK**: 36

## 문제 해결

### 일반적인 빌드 문제

**"google-services.json not found"**
- Firebase Console에서 다운로드하여 `app/` 디렉토리에 배치
- 이 파일은 절대 커밋하지 말 것 (`.gitignore`에 포함됨)

**"No credentials available" (Google 로그인 실패)**
- `./gradlew signingReport` 실행하여 SHA-1 확인
- Firebase Console → 프로젝트 설정 → Android 앱에 SHA-1 지문 추가

**HTTP 404 또는 네트워크 에러**
- `local.properties`의 `BASE_URL` 확인
- 백엔드가 실행 중이고 ngrok URL이 최신인지 확인
- Logcat에서 `AuthRepository` 로그 확인

**Hilt 에러 ("missing binding", "cannot provide")**
- `ReadPickApplication`에 `@HiltAndroidApp`이 있는지 확인
- 모듈이 올바른 컴포넌트에 설치되었는지 확인 (`SingletonComponent` vs `ViewModelComponent`)
- 프로젝트 리빌드: `./gradlew clean build`

### 네트워크 요청 디버깅

모든 네트워크 요청은 `LoggingInterceptor`를 통해 로깅됩니다. Logcat 확인:
- `OkHttp`: 원시 HTTP 요청/응답
- `AuthRepository`: 요청/응답 세부 정보가 포함된 백엔드 API 호출 로그

## 코드 규칙

### 패키지 구조
- `presentation/`은 기능 기반 (예: `presentation/auth/login/`)
- `data/`와 `domain/`은 레이어 기반

### 네이밍 규칙
- ViewModel: `{Feature}ViewModel`
- Screen: `{Feature}Screen`
- Repository: `{Domain}Repository` (인터페이스) 및 `{Domain}RepositoryImpl` (구현체)
- API 서비스: `{Domain}Api`
- DTO: `{Purpose}Request` / `{Purpose}Response`

### 상태 관리
- UI 상태에 sealed class 또는 data class 사용
- ViewModel에서 StateFlow를 통해 상태 변경 emit
- Composable에서 `collectAsState()`로 상태 수집

## 백엔드 API 통합

앱은 백엔드가 다음 계약을 따르기를 기대합니다:

**인증 엔드포인트**: `POST /v1/api/auth/google`
- 요청: `{ "idToken": "..." }`
- 응답: `{ "success": true, "data": { "accessToken": "...", "email": "...", "name": "...", "picture": "..." } }`

**일반 API 응답 형식**:
```kotlin
{
  "success": Boolean,
  "data": T?,
  "message": String?
}
```

모든 인증된 요청은 `AuthInterceptor`를 통해 자동으로 `Authorization: Bearer {jwt}` 헤더를 포함합니다.
